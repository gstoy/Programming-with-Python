<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Drawing from reference &#8212; Textual Programming in Python</title>
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/activecode.css" />
    <link rel="stylesheet" type="text/css" href="../_static/codemirror.css" />
    <link rel="stylesheet" type="text/css" href="../_static/clickable.css" />
    <link rel="stylesheet" type="text/css" href="../_static/pytutor.css" />
    <link rel="stylesheet" type="text/css" href="../_static/modal-basic.css" />
    <link rel="stylesheet" type="text/css" href="../_static/datafile.css" />
    <link rel="stylesheet" type="text/css" href="../_static/dragndrop.css" />
    <link rel="stylesheet" type="text/css" href="../_static/fitb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/matrixeq.css" />
    <link rel="stylesheet" type="text/css" href="../_static/parsons.css" />
    <link rel="stylesheet" type="text/css" href="../_static/lib/prettify.css" />
    <link rel="stylesheet" type="text/css" href="../_static/poll.css" />
    <link rel="stylesheet" type="text/css" href="../_static/showEval.css" />
    <link rel="stylesheet" type="text/css" href="../_static/tabbedstuff.css" />
    <link rel="stylesheet" type="text/css" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="../_static/video.css" />
    <link rel="stylesheet" type="text/css" href="../_static/karel.css" />
    <link rel="stylesheet" type="text/css" href="../_static/notes.css" />
    <link rel="stylesheet" href="../_static/user-highlights.css" type="text/css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.1.1/css/all.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-4.0.0-dist/css/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/flatly.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/petlja.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/runestonebase.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/jquery.highlight.js"></script>
    <script type="text/javascript" src="../_static/bookfuncs.js"></script>
    <script type="text/javascript" src="../_static/codemirror.js"></script>
    <script type="text/javascript" src="../_static/xml.js"></script>
    <script type="text/javascript" src="../_static/css.js"></script>
    <script type="text/javascript" src="../_static/python.js"></script>
    <script type="text/javascript" src="../_static/htmlmixed.js"></script>
    <script type="text/javascript" src="../_static/javascript.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/CLDRPluralRuleParser.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.messagestore.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.fallbacks.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.language.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.parser.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.emitter.js"></script>
    <script type="text/javascript" src="../_static/jquery_i18n/jquery.i18n.emitter.bidi.js"></script>
    <script type="text/javascript" src="../_static/activecode-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/skulpt.min.js"></script>
    <script type="text/javascript" src="../_static/skulpt-stdlib.js"></script>
    <script type="text/javascript" src="../_static/activecode.js"></script>
    <script type="text/javascript" src="../_static/clike.js"></script>
    <script type="text/javascript" src="../_static/timed_activecode.js"></script>
    <script type="text/javascript" src="../_static/animationbase.js"></script>
    <script type="text/javascript" src="../_static/mchoice.js"></script>
    <script type="text/javascript" src="../_static/timedmc.js"></script>
    <script type="text/javascript" src="../_static/timed.js"></script>
    <script type="text/javascript" src="../_static/mchoice-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/clickable.js"></script>
    <script type="text/javascript" src="../_static/timedclickable.js"></script>
    <script type="text/javascript" src="../_static/d3.v2.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.ba-bbq.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.jsPlumb-1.3.10-all-min.js"></script>
    <script type="text/javascript" src="../_static/pytutor.js"></script>
    <script type="text/javascript" src="../_static/codelens.js"></script>
    <script type="text/javascript" src="../_static/datafile.js"></script>
    <script type="text/javascript" src="../_static/dragndrop.js"></script>
    <script type="text/javascript" src="../_static/timeddnd.js"></script>
    <script type="text/javascript" src="../_static/dragndrop-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/fitb.js"></script>
    <script type="text/javascript" src="../_static/timedfitb.js"></script>
    <script type="text/javascript" src="../_static/fitb-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/matrixeq.js"></script>
    <script type="text/javascript" src="../_static/lib/prettify.js"></script>
    <script type="text/javascript" src="../_static/lib/hammer.min.js"></script>
    <script type="text/javascript" src="../_static/parsons.js"></script>
    <script type="text/javascript" src="../_static/parsons-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/timedparsons.js"></script>
    <script type="text/javascript" src="../_static/poll.js"></script>
    <script type="text/javascript" src="../_static/reveal.js"></script>
    <script type="text/javascript" src="../_static/shortanswer.js"></script>
    <script type="text/javascript" src="../_static/timed_shortanswer.js"></script>
    <script type="text/javascript" src="../_static/showEval.js"></script>
    <script type="text/javascript" src="../_static/tabbedstuff.js"></script>
    <script type="text/javascript" src="../_static/runestonevideo.js"></script>
    <script type="text/javascript" src="../_static/karelCorner.js"></script>
    <script type="text/javascript" src="../_static/karelRobot.js"></script>
    <script type="text/javascript" src="../_static/karelWorld.js"></script>
    <script type="text/javascript" src="../_static/karelRobotDrawer.js"></script>
    <script type="text/javascript" src="../_static/karelUI.js"></script>
    <script type="text/javascript" src="../_static/karel.js"></script>
    <script type="text/javascript" src="../_static/karel-i18n.en.js"></script>
    <script type="text/javascript" src="../_static/notes.js"></script>
    <script type="text/javascript" src="../_static/pygamelib-init.js"></script>
    <script type="text/javascript" src="../_static/blockly/blockly_compressed.js"></script>
    <script type="text/javascript" src="../_static/blockly/blocks_compressed.js"></script>
    <script type="text/javascript" src="../_static/blockly/python_compressed.js"></script>
    <script type="text/javascript" src="../_static/blockly/msg-sr.js"></script>
    <script type="text/javascript" src="../_static/blockpy/utilities.js"></script>
    <script type="text/javascript" src="../_static/blockpy/python_errors.js"></script>
    <script type="text/javascript" src="../_static/blockpy/ast_node_visitor.js"></script>
    <script type="text/javascript" src="../_static/blockpy/abstract_interpreter.js"></script>
    <script type="text/javascript" src="../_static/blockpy/pytifa.js"></script>
    <script type="text/javascript" src="../_static/blockpy/abstract_interpreter_definitions.js"></script>
    <script type="text/javascript" src="../_static/blockpy/python_to_blockly.js"></script>
    <script type="text/javascript" src="../_static/blockpy/imported.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/class.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/comment.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/comprehensions.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/dict.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/if.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/io.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/lists.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/sets.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/loops.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/parking.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/tuple.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/turtles.js"></script>
    <script type="text/javascript" src="../_static/blockpy/blocks/text.js"></script>
    <script type="text/javascript" src="../_static/blockpy-modal.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/jquery-ui-1.10.3.custom.min.js"></script>
    <script type="text/javascript" src="../_static/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-4.0.0-dist/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-4.0.0-dist/js/bootstrap.bundle.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <script type="text/javascript" src="../_static/waypoints.min.js"></script>
    <script type="text/javascript" src="../_static/rangy-core.js"></script>
    <script type="text/javascript" src="../_static/rangy-textrange.js"></script>
    <script type="text/javascript" src="../_static/rangy-cssclassapplier.js"></script>
    <script type="text/javascript" src="../_static/user-highlights.js"></script>
    <script type="text/javascript" src="../_static/jquery.idle-timer.js"></script>
    <script type="text/javascript" src="../_static/processing-1.4.1.min.js"></script>
    <script type="text/javascript" src="../_static/jquery.hotkey.js"></script>
    <script type="text/javascript" src="../_static/jquery-migrate-1.2.1.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Drawing from reference - допълнителни примери" href="03_PyGame_12b_Drawing_Given_Examples_opt.html" />
    <link rel="prev" title="Рисуване на прави линии и многоъгълници" href="03_PyGame_11b_Drawing_LinePolygon.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' name='viewport' />
<link rel="shortcut icon" href="../_static/favicon.ico" type="image/ico" />

<script type="text/javascript">
  eBookConfig = {};
  eBookConfig.host = 'http://127.0.0.1:8000' ? 'http://127.0.0.1:8000' : 'http://127.0.0.1:8000';
  eBookConfig.app = eBookConfig.host+'/runestone';
  eBookConfig.ajaxURL = eBookConfig.app+'/ajax/';
  eBookConfig.course = 'TxtProgInPython';
  eBookConfig.logLevel = 0;
  eBookConfig.loginRequired = false;
  eBookConfig.build_info = "";
  eBookConfig.isLoggedIn = false;
  eBookConfig.useRunestoneServices = false;
  eBookConfig.python3 = true;
  eBookConfig.basecourse = 'TxtProgInPython';
  eBookConfig.runestone_version = '3.1.1';
  eBookConfig.imagesDir = '../_images/';
  eBookConfig.staticDir = '../_static/';
  if(typeof(Sk) != "undefined")
      Sk.imgPath = eBookConfig.imagesDir;
</script>

<div id="fb-root"></div>



  </head><body>


<!-- Begin navbar -->

<nav id="navbar" class="navbar navbar-default navbar-fixed-top" role="navigation">

  <div class="container">

    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
     <img src="../_static/img/logo.png" style="width:80px; height: 80px;"> 
    </div>

    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1" style="margin-top: 10px; margin-left: 25px;">
      <ul class="nav navbar-nav">
        <li class="active"><a href="../">Textual Programming in Python</a></li>
      </ul>
    </div>
  </div>
</nav>
<br/>


<div class="container col-md-12" id="continue-reading"></div>

<div class="container col-md-8 col-md-offset-2" id="main-content">
  
  <div class="section" id="drawing-from-reference">
<h1>Drawing from reference<a class="headerlink" href="#drawing-from-reference" title="Permalink to this headline">¶</a></h1>
<p>Току-що научихме как да рисуваме някои основни фигури в средата на PyGame, използвайки функции за рисуване. Както беше споменато преди, всички такива изображения се състоят от пиксели. Това са така наречените растерни или растерни изображения. Видяхме, че за да нарисуваме основни фигури, трябва да знаем координатите на пикселите, които определят всяка такава форма. В по-реалистична ситуация обаче тези координати не се дават директно и ние трябва да ги определяме сами.</p>
<p>Ако искаме програмно да генерираме изображение, използвайки съществуваща растерна карта като ориентир, можем да определим координатите на точките от даденото изображение. Можем да увеличим изображението в една от програмите за преглед на изображения, за да накараме всеки пиксел да изглежда като квадрат. Това може да изглежда така:</p>
<a class="reference internal image-reference" href="../_images/ladder_grid.png"><img alt="../_images/ladder_grid.png" class="align-center" src="../_images/ladder_grid.png" style="width: 300px;" /></a>
<p>Можем да видим, че това изображение е генерирано чрез изчертаване на 4 хоризонтални и 2 вертикални линии, а също така, че всичките 6 линии са черни и 1 пиксела широки. Тъй като знаем, че <em>x</em> координатата се брои отляво надясно и <em>y</em> отгоре надолу, както и че броенето започва от нула, можем да определим координатите на началната и крайната точка на всички шест реда просто като преброим.</p>
<div class="section" id="id1">
<h2>Стълбица<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Прочетете координатите от увеличеното изображение по-горе и напишете програма, която очертава стълби като тези.</p>
<p><strong>Съвет:</strong> Чрез преброяване (от нула) можем да открием, че координатите на крайните точки на лявата вертикална линия са (5, 3) и (5, 36). Координатите на крайните точки на останалите 5 линии трябва да се определят по същия начин.</p>

<div data-childcomponent="PyGame__drawing_ladder_assist" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_ladder_assist data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
              data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(20, 40, &quot;ladder&quot;)

# -*- acsection: main -*-
canvas.fill(pg.Color(&quot;white&quot;)) # paint background

pg.draw.line(canvas, pg.Color(&quot;black&quot;), ( 5, 3), ( 5, 36), 1)  # left side
pg.draw.line(canvas, pg.Color(&quot;black&quot;), (14, 3), (14, 36), 1)  # right side

pg.draw.line(canvas, pg.Color(&quot;black&quot;), (5,  9), (14,  9), 1) # step
pg.draw.line(canvas, pg.Color(&quot;black&quot;), (5, 16), (14, 16), 1) # step
pg.draw.line(canvas, pg.Color(&quot;black&quot;), (5, 23), (14, 23), 1) # step
pg.draw.line(canvas, pg.Color(&quot;black&quot;), (5, 30), (14, 30), 1) # step

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">
canvas.fill(pg.Color("white")) # paint background

pg.draw.line(canvas, pg.Color("black"), ( 5, 3), ( 5, 36), 1)  # left side
pg.draw.line(canvas, pg.Color("black"), (???, ???), (???, ???), 1)  # right side

pg.draw.line(canvas, pg.Color("black"), (???, ???), (???, ???), 1) # step
pg.draw.line(canvas, pg.Color("black"), (???, ???), (???, ???), 1) # step
pg.draw.line(canvas, pg.Color("black"), (???, ???), (???, ???), 1) # step
pg.draw.line(canvas, pg.Color("black"), (???, ???), (???, ???), 1) # step
</textarea>
</div>
<p>Реалният размер на изображението е много малък, само 20 пиксела широк и 40 пиксела висок. Бихме могли да определим и координатите на точките за по-големи изображения, като броим, но това би било досадно и податливо на грешки (затова в този пример избрахме толкова малко изображение). Добрата новина е, че програмите за преглед и редактиране на изображения обикновено показват координатите на пиксела, върху който в момента е курсорът на мишката. Координатите на курсора обикновено се пишат някъде в лентата на състоянието в долната част на прозореца, в който се изпълнява програмата, често в долния ляв ъгъл.</p>
<p>Например, в програмата за рисуване <em>Paint</em>, когато изображението е увеличено 8 пъти и се показва решетката, която подчертава отделните пиксели, лесно можем да позиционираме курсора върху всеки пиксел и да четем координатите му. На тази снимка курсорът на мишката беше върху червения пиксел, който, както казахме по-рано, има координатите (5, 36).</p>
<a class="reference internal image-reference" href="../_images/read_xy.png"><img alt="../_images/read_xy.png" class="align-center" src="../_images/read_xy.png" style="width: 600px;" /></a>
<hr class="docutils" />
<p>В следващите задачи трябва да напишете програма, която изчертава чертеж възможно най-близко до дадената. Можете да видите чертежите, които трябва да нарисувате, когато кликнете върху бутона „Задача за игра“.</p>
<p>За да ви помогне да определите координатите на важни точки в чертеж, програмата, която стартирате, като щракнете върху бутона „Задача за игра“, освен чертежа, ще покаже координатите на точката, където е курсорът на мишката. За да се улесни четенето, във всички примери координатите на всички значими точки са закръглени до 5 пиксела (координатите завършват с нула или пет).</p>
<p>Ако искате да решите тези задачи извън уеб браузъра, в своята програма за програмиране можете да изтеглите изображенията, които вашите програми трябва да нарисуват, да ги отворите в преглед на изображения и да прочетете координатите на важните точки там.</p>
<a class="reference internal image-reference" href="../_images/drawing_grid_antenna.png"><img alt="../_images/drawing_grid_antenna.png" src="../_images/drawing_grid_antenna.png" style="width: 120px;" /></a>
<a class="reference internal image-reference" href="../_images/drawing_grid_balance.png"><img alt="../_images/drawing_grid_balance.png" src="../_images/drawing_grid_balance.png" style="width: 120px;" /></a>
<a class="reference internal image-reference" href="../_images/drawing_grid_house.png"><img alt="../_images/drawing_grid_house.png" src="../_images/drawing_grid_house.png" style="width: 120px;" /></a>
<a class="reference internal image-reference" href="../_images/drawing_grid_smiley.png"><img alt="../_images/drawing_grid_smiley.png" src="../_images/drawing_grid_smiley.png" style="width: 120px;" /></a>
<a class="reference internal image-reference" href="../_images/drawing_grid_trees.png"><img alt="../_images/drawing_grid_trees.png" src="../_images/drawing_grid_trees.png" style="width: 120px;" /></a>
</div>
<div class="section" id="id2">
<h2>Антена<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Преди кабелна телевизия телевизионни сигнали бяха получени от антени, които обикновено бяха поставени на покривите на домовете и сградите на хората. В тази задача трябва да се изготви една такава антена.</p>
<p>Както можете да видите, когато стартирате примера, чертежът се състои от седем реда. Ширината на вертикалната линия е 4 пиксела, горните две хоризонтални 1, средните два 2, а долните два 3 пиксела. Цветът на фона е “skyblue”.</p>

<div data-childcomponent="PyGame__drawing_antenna_simple_assist" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_antenna_simple_assist data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
           data-playtask="true"   data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Antenna&quot;)

# -*- acsection: main -*-
(width, height) = (300, 300)
def draw():
    canvas.blit(user_canvas, (0, 0))  # attach users drawing
    
    # axes
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (mouse_x, 0), (mouse_x, height), 1) # vertical mouse line
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (0, mouse_y), (width, mouse_y), 1) # horizontal mouse line

    # write coordinates
    str_x, str_y = str(mouse_x), str(mouse_y)
    xt_y, yt_y = (5, mouse_y - 25) if 2 * mouse_y &gt; height else (height - 25, mouse_y + 5)
    xt_x, yt_x = (mouse_x - 50, 5) if 2 * mouse_x &gt; width else (mouse_x + 5, width - 50)
    im_x = font.render(str_x, True, pg.Color(&quot;black&quot;))
    im_y = font.render(str_y, True, pg.Color(&quot;black&quot;))
    canvas.blit(im_x, (xt_x, xt_y))
    canvas.blit(im_y, (yt_x, yt_y))

def handle_event(event):
    global mouse_x, mouse_y
    if event.type == pg.MOUSEMOTION:    # the mouse is moved
        mouse_x, mouse_y = event.pos
        return True                     # re-plot the scene
    return False                        # no need to re-plot the scene

################# drawing
user_canvas = pg.Surface((width, height)) # the canvas on which user image is drawn
user_canvas.fill(pg.Color(&quot;skyblue&quot;)) # paint background

pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), (150,  50), (150, 250), 4)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), (120,  75), (180,  75), 1)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), (110, 100), (190, 100), 1)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), (100, 125), (200, 125), 2)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), ( 90, 150), (210, 150), 2)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), ( 80, 175), (220, 175), 3)
pg.draw.line(user_canvas, pg.Color(&apos;black&apos;), ( 70, 200), (230, 200), 3)
#################

font = pg.font.SysFont(&quot;Arial&quot;, 20)
font.set_bold(True)
mouse_x, mouse_y = 0, 0

should_redraw = True
done = False

while not done:
    if should_redraw:
        draw()
        pg.display.update()
        should_redraw = False

    event = pg.event.wait()
    if event.type == pg.QUIT:
        done = True
    else:
        should_redraw = handle_event(event)
        
# Completion of the hidden part of the program, that works as an example
pg.quit()
pg.time.set_timer(pg.QUIT,50)
pg.time.wait(70)
pg.time.set_timer(pg.QUIT,0)

# Completion of user program is in the separate section

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">
pg.draw.line(canvas, color???, (150, y1???,), (150, y2???,), 4)
pg.draw.line(canvas, ???
pg.draw.line(canvas, ???
pg.draw.line(canvas, ???
pg.draw.line(canvas, ???
pg.draw.line(canvas, ???
pg.draw.line(canvas, ???
</textarea>
</div>

    <div data-component="reveal" id="PyGame__drawing_antenna_simple_reveal"   data-showtitle="Покажи отговора" data-hidetitle="Скрий отговора">
    <p>Пълната програма е предоставена, можете да опитате и тук.</p>

<div data-childcomponent="PyGame__drawing_antenna_simple_solution" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_antenna_simple_solution data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
              data-modaloutput="true" data-hidehistory=true
    data-includesrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Antenna&quot;)

# -*- acsection: main -*-
canvas.fill(pg.Color(&quot;skyblue&quot;)) # paint background

pg.draw.line(canvas, pg.Color(&apos;black&apos;), (150,  50), (150, 250), 4)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), (120,  75), (180,  75), 1)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), (110, 100), (190, 100), 1)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), (100, 125), (200, 125), 2)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), ( 90, 150), (210, 150), 2)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), ( 80, 175), (220, 175), 3)
pg.draw.line(canvas, pg.Color(&apos;black&apos;), ( 70, 200), (230, 200), 3)

# -*- acsection: after-main -*-
pygamebg.wait_loop()
"   data-enablecopy="true">


</textarea>
</div>

    </div>
    </div>
<div class="section" id="balance-scale">
<h2>Balance scale<a class="headerlink" href="#balance-scale" title="Permalink to this headline">¶</a></h2>
<p>Тази рисунка се състои от линия (чиято ширина е 2) и три триъгълника. Средният триъгълник, който представлява опората на баланса, се запълва с цвят, така че при начертаването му параметърът на ширината трябва да се пропусне, докато за останалите два триъгълника трябва да се посочи ширина 2.</p>

<div data-childcomponent="PyGame__drawing_balance" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_balance data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
           data-playtask="true"   data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Balance&quot;)

# -*- acsection: main -*-
(width, height) = (300, 300)
def draw():
    canvas.blit(user_canvas, (0, 0))  # attach users drawing
    
    # axes
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (mouse_x, 0), (mouse_x, height), 1) # vertical mouse line
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (0, mouse_y), (width, mouse_y), 1) # horizontal mouse line

    # write coordinates
    str_x, str_y = str(mouse_x), str(mouse_y)
    xt_y, yt_y = (5, mouse_y - 25) if 2 * mouse_y &gt; height else (height - 25, mouse_y + 5)
    xt_x, yt_x = (mouse_x - 50, 5) if 2 * mouse_x &gt; width else (mouse_x + 5, width - 50)
    im_x = font.render(str_x, True, pg.Color(&quot;black&quot;))
    im_y = font.render(str_y, True, pg.Color(&quot;black&quot;))
    canvas.blit(im_x, (xt_x, xt_y))
    canvas.blit(im_y, (yt_x, yt_y))

def handle_event(event):
    global mouse_x, mouse_y
    if event.type == pg.MOUSEMOTION:    # the mouse is moved
        mouse_x, mouse_y = event.pos
        return True                     # re-plot the scene
    return False                        # no need to re-plot the scene

################# drawing
user_canvas = pg.Surface((width, height)) # the canvas on which user image is drawn
user_canvas.fill(pg.Color(&quot;green&quot;)) # paint background

pg.draw.line(user_canvas, pg.Color(&quot;brown&quot;), (60, 100), (240,  100), 2)                              # beam
pg.draw.polygon(user_canvas, pg.Color(&quot;brown&quot;), [(100, 120), (150, 100), (200, 120), (100, 120)])    # support
pg.draw.polygon(user_canvas, pg.Color(&quot;brown&quot;), [( 30, 200), ( 60, 100), ( 90, 200), ( 30, 200)], 2) # left pan
pg.draw.polygon(user_canvas, pg.Color(&quot;brown&quot;), [(210, 200), (240, 100), (270, 200), (210, 200)], 2) # right pan
#################

font = pg.font.SysFont(&quot;Arial&quot;, 20)
font.set_bold(True)
mouse_x, mouse_y = 0, 0

should_redraw = True
done = False

while not done:
    if should_redraw:
        draw()
        pg.display.update()
        should_redraw = False

    event = pg.event.wait()
    if event.type == pg.QUIT:
        done = True
    else:
        should_redraw = handle_event(event)

# Completion of the hidden part of the program, that works as an example
pg.quit()
pg.time.set_timer(pg.QUIT,50)
pg.time.wait(70)
pg.time.set_timer(pg.QUIT,0)

# Completion of user program is in the separate section

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">
canvas.fill(color???)) # paint background green
pg.draw.line(canvas, color???, (x1???, y1???), (x2???,  y2???), 2) # beam

# support
pg.draw.polygon(canvas, pg.Color("brown"), [(???, ???), ...

# left pan
pg.draw.polygon(canvas, pg.Color("brown"), [(???, ???), ...

# right pan
pg.draw.polygon(canvas, pg.Color("brown"), [(???, ???), ...
</textarea>
</div>
</div>
<div class="section" id="id3">
<h2>Усмивчо<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>В тази задача работата, която трябва да се свърши, е малко по-сложна. Тъй като чертежът е съставен от кръгове и елипси, ние не можем точно да прочетем всички координати и измервания, които са ни необходими директно. Това, което можем да направим, е да прочетем за всяка елипса координатата: math: <cite>x</cite> на най-лявата и най-дясната му точка ((<span class="math notranslate nohighlight">\(X_L\)</span> и <span class="math notranslate nohighlight">\(X_R\)</span>), както и <span class="math notranslate nohighlight">\(y \)</span> и <span class="math notranslate nohighlight">\(Y_B\)</span>). След това ширината и височината на елипсата могат да бъдат изчислени като разликите на съответното <span class="math notranslate nohighlight">\(x\)</span> ( за ширина) и <span class="math notranslate nohighlight">\(y\)</span> координати (за височина).</p>
<p>Що се отнася до кръга, имаме различни опции:</p>
<ul class="simple">
<li><p>можем да нарисуваме кръга като елипса, вписана в квадрат (с помощта на функцията <em>pg.draw.ellipse</em>)</p></li>
<li><p>можем да приблизим координатите на центъра на кръга</p></li>
<li><p>ако искаме да определим координатите на центъра на кръга по-точно, първо можем да намерим точките <span class="math notranslate nohighlight">\(X_L\)</span>, <span class="math notranslate nohighlight">\(X_R\)</span>, <span class="math notranslate nohighlight">\(Y_T\)</span> и <span class="math notranslate nohighlight">\(Y_B\)</span> като направихме за елипси и след това изчислихме координатите на центъра, използвайки формули <span class="math notranslate nohighlight">\(X_c = {{X_R + X_L}\over2}\)</span> и <span class="math notranslate nohighlight">\(Y_c={{Y_T + Y_B}\over2}\)</span></p></li>
</ul>

<div data-childcomponent="PyGame__drawing_smiley" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_smiley data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
           data-playtask="true"   data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Pygame&quot;)

# -*- acsection: main -*-
(width, height) = (300, 300)
def draw():
    canvas.blit(user_canvas, (0, 0))  # attach users drawing
    
    # axes
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (mouse_x, 0), (mouse_x, height), 1) # vertical mouse line
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (0, mouse_y), (width, mouse_y), 1) # horizontal mouse line

    # write coordinates
    str_x, str_y = str(mouse_x), str(mouse_y)
    xt_y, yt_y = (5, mouse_y - 25) if 2 * mouse_y &gt; height else (height - 25, mouse_y + 5)
    xt_x, yt_x = (mouse_x - 50, 5) if 2 * mouse_x &gt; width else (mouse_x + 5, width - 50)
    im_x = font.render(str_x, True, pg.Color(&quot;black&quot;))
    im_y = font.render(str_y, True, pg.Color(&quot;black&quot;))
    canvas.blit(im_x, (xt_x, xt_y))
    canvas.blit(im_y, (yt_x, yt_y))

def handle_event(event):
    global mouse_x, mouse_y
    if event.type == pg.MOUSEMOTION:    # the mouse is moved
        mouse_x, mouse_y = event.pos
        return True                     # re-plot the scene
    return False                        # no need to re-plot the scene

################# drawing
user_canvas = pg.Surface((width, height)) # the canvas on which user image is drawn
user_canvas.fill(pg.Color(&quot;white&quot;)) # paint background

pg.draw.circle(user_canvas, pg.Color(&quot;yellow&quot;), (150, 150), 100) # head
pg.draw.ellipse(user_canvas, pg.Color(&quot;black&quot;), (100, 90, 30, 60)) # left eye
pg.draw.ellipse(user_canvas, pg.Color(&quot;black&quot;), (170, 90, 30, 60)) # right eye
pg.draw.ellipse(user_canvas, pg.Color(&quot;white&quot;), (100, 190, 100, 20)) # the inside of the mouth
pg.draw.ellipse(user_canvas, pg.Color(&quot;black&quot;), (100, 190, 100, 20), 2) # the edge of the mouth
#################

font = pg.font.SysFont(&quot;Arial&quot;, 20)
font.set_bold(True)
mouse_x, mouse_y = 0, 0

should_redraw = True
done = False

while not done:
    if should_redraw:
        draw()
        pg.display.update()
        should_redraw = False

    event = pg.event.wait()
    if event.type == pg.QUIT:
        done = True
    else:
        should_redraw = handle_event(event)

# Completion of the hidden part of the program, that works as an example
pg.quit()
pg.time.set_timer(pg.QUIT,50)
pg.time.wait(70)
pg.time.set_timer(pg.QUIT,0)

# Completion of user program is in the separate section

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">
canvas.fill(color???) # paint background white
pg.draw.circle(canvas, color???, (x???, y???), r???)           # head
pg.draw.ellipse(canvas, color???, (x???, y???, w???, h???))    # left eye
pg.draw.ellipse(canvas, ???, (???, ???, ???, ???))             # right eye
pg.draw.ellipse(canvas, ???, (???, ???, ???, ???))             # mouth interior
pg.draw.ellipse(canvas, ???, (???, ???, ???, ???), thickness?) # mouth edge
</textarea>
</div>
</div>
<div class="section" id="k">
<h2>Kъща<a class="headerlink" href="#k" title="Permalink to this headline">¶</a></h2>
<p>Чертежът на къща се състои от кафяв правоъгълник и червен триъгълник. Можем да нарисуваме триъгълника като многоъгълник с три върха. Слънцето е изобразено като оранжев кръг, а тревата като зелен правоъгълник. Имайте предвид реда на рисуване за тревата и слънцето.</p>
<p>Достатъчно е да прочетете приблизително координатите на центъра на окръжността, представяща Слънцето. За тези, които искат малко математическо предизвикателство, имайте предвид, че координатите на центъра могат да бъдат по-точно определени като предишната задача, въпреки че най-ниската точка не се вижда и координатата <span class="math notranslate nohighlight">\(Y_B\)</span> не може да бъде прочетена.</p>
<p>Ако искате да видите как можете да определите координатите на центъра с по-точно четене и изчисляване, кликнете върху бутона “Определяне на центъра”.</p>

    <div data-component="reveal" id="PyGame__drawing_house_circle_center_reveal"   data-showtitle="Determining the center" data-hidetitle="Hide determining the center">
    <blockquote>
<div><p>Както в предишната задача, нека <span class="math notranslate nohighlight">\(X_L\)</span> и <span class="math notranslate nohighlight">\(X_R\)</span> обозначават <span class="math notranslate nohighlight">\(x\)</span> координатите на най-лявата и дясната точка на окръжността, която представлява Слънцето, и <span class="math notranslate nohighlight">\(Y_T\)</span> , <span class="math notranslate nohighlight">\(Y_B\)</span> и <span class="math notranslate nohighlight">\(y\)</span> координати на най-високата и най-ниската точка на този кръг.</p>
<p>Можем да определим :math: <cite>x</cite> координатата на центъра, както направихме в предишния пример, <span class="math notranslate nohighlight">\(X_C = {{X_R + X_L} \over 2}\)</span>.</p>
<p>Тъй като най-ниската точка на кръга не се вижда, не можем да прочетем стойността <span class="math notranslate nohighlight">\(Y_B\)</span>, но можем да определим радиуса <span class="math notranslate nohighlight">\(r\)</span>, използвайки <span class="math notranslate nohighlight">\(r = X_C - X_L\)</span> или <span class="math notranslate nohighlight">\(r = X_R - X_C\)</span>. Сега <span class="math notranslate nohighlight">\(y\)</span> координатата на центъра се получава лесно: <span class="math notranslate nohighlight">\(Y_C = Y_T + r\)</span>, така че дори не ни трябваше <span class="math notranslate nohighlight">\(Y_B\)</span>.</p>
</div></blockquote>

    </div>
    
<div data-childcomponent="PyGame__drawing_house" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_house data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
           data-playtask="true"   data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Кућа&quot;)

# -*- acsection: main -*-
(width, height) = (300, 300)
def draw():
    canvas.blit(user_canvas, (0, 0))  # attach users drawing
    
    # axes
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (mouse_x, 0), (mouse_x, height), 1) # vertical mouse line
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (0, mouse_y), (width, mouse_y), 1) # horizontal mouse line

    # write coordinates
    str_x, str_y = str(mouse_x), str(mouse_y)
    xt_y, yt_y = (5, mouse_y - 25) if 2 * mouse_y &gt; height else (height - 25, mouse_y + 5)
    xt_x, yt_x = (mouse_x - 50, 5) if 2 * mouse_x &gt; width else (mouse_x + 5, width - 50)
    im_x = font.render(str_x, True, pg.Color(&quot;black&quot;))
    im_y = font.render(str_y, True, pg.Color(&quot;black&quot;))
    canvas.blit(im_x, (xt_x, xt_y))
    canvas.blit(im_y, (yt_x, yt_y))
def handle_event(event):
    global mouse_x, mouse_y
    if event.type == pg.MOUSEMOTION:    # the mouse is moved
        mouse_x, mouse_y = event.pos
        return True                     # re-plot the scene
    return False                        # no need to re-plot the scene

################# drawing
user_canvas = pg.Surface((width, height)) # the canvas on which user image is drawn
user_canvas.fill(pg.Color(&quot;lightblue&quot;)) # paint background

pg.draw.circle(user_canvas, pg.Color(&quot;orange&quot;), (250, 180), 30)   # sun
pg.draw.rect(user_canvas, pg.Color(&quot;green&quot;), (0, 200, 300, 100))  # grass
pg.draw.rect(user_canvas, pg.Color(&quot;brown&quot;), (50, 150, 150, 100)) # house
pg.draw.polygon(user_canvas, pg.Color(&quot;red&quot;), [(50, 150), (125, 100), (200, 150)]) # roof
#################

font = pg.font.SysFont(&quot;Arial&quot;, 20)
font.set_bold(True)
mouse_x, mouse_y = 0, 0

should_redraw = True
done = False

while not done:
    if should_redraw:
        draw()
        pg.display.update()
        should_redraw = False

    event = pg.event.wait()
    if event.type == pg.QUIT:
        done = True
    else:
        should_redraw = handle_event(event)

# Completion of the hidden part of the program, that works as an example
pg.quit()
pg.time.set_timer(pg.QUIT,50)
pg.time.wait(70)
pg.time.set_timer(pg.QUIT,0)

# Completion of user program is in the separate section

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">
canvas.fill(color???) # paint background light gray
???
???
pg.draw.rect(canvas, color???, (x???, y???, w???, h???)) # house
pg.draw.polygon(canvas, color???, [(x1???, y1???), (x2???, y2???), (x3???, y3???)]) # roof
</textarea>
</div>
</div>
<div class="section" id="id4">
<h2>Дървета<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>Трябва да бъдат начертани три еднакви дървета, така че всяко следващо дърво да се получи, като се премести предишното надясно. Очевидно тази задача би могла да бъде дадена чрез просто описание на първото дърво и посочване на разстоянието между две съседни дървета. Програмата, която рисува изображението, се дава все пак, защото използването на изображение за задаване на задача е по-ясно и по-просто.</p>
<p>За да направите задачата малко по-скоро като реална ситуация (в която няма изображение), в този пример четенето на <span class="math notranslate nohighlight">\(x\)</span> координатата е умишлено деактивирана за дясната страна на изображението. Всички необходими координати, които не можете да четете, могат да бъдат изчислени.</p>

<div data-childcomponent="PyGame__drawing_trees" class="course-box course-box-problem course-content">

<textarea data-component="activecode" id=PyGame__drawing_trees data-lang="python" 
      data-timelimit=25000    
    data-audio=''   
           data-playtask="true"   data-modaloutput="true" data-hidehistory=true
      data-includexsrc="# -*- acsection: general-init -*-
import pygame as pg, pygamebg
canvas = pygamebg.open_window(300, 300, &quot;Pygame&quot;)

# -*- acsection: main -*-
(width, height) = (300, 300)
def draw():
    canvas.blit(user_canvas, (0, 0))  # attach users drawing
    
    # axes
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (mouse_x, 0), (mouse_x, height), 1) # vertical mouse line
    pg.draw.line(canvas, pg.Color(&quot;black&quot;), (0, mouse_y), (width, mouse_y), 1) # horizontal mouse line

    # write coordinates
    str_x, str_y = str(mouse_x), str(mouse_y)
    xt_y, yt_y = (5, mouse_y - 25) if 2 * mouse_y &gt; height else (height - 25, mouse_y + 5)
    xt_x, yt_x = (mouse_x - 50, 5) if 2 * mouse_x &gt; width else (mouse_x + 5, width - 50)
    im_x = font.render(str_x, True, pg.Color(&quot;black&quot;))
    im_y = font.render(str_y, True, pg.Color(&quot;black&quot;))
    if 2 * mouse_x &lt; width: # write only for the left side of the screen
        canvas.blit(im_x, (xt_x, xt_y))
    canvas.blit(im_y, (yt_x, yt_y))

def handle_event(event):
    global mouse_x, mouse_y
    if event.type == pg.MOUSEMOTION:    # the mouse is moved
        mouse_x, mouse_y = event.pos
        return True                     # re-plot the scene
    return False                        # no need to re-plot the scene

################# drawing
user_canvas = pg.Surface((width, height)) # the canvas on which user image is drawn
user_canvas.fill(pg.Color(&quot;green&quot;)) # paint background

pg.draw.rect(user_canvas, pg.Color(&quot;brown&quot;), (40, 180, 20, 100))        # first tree
pg.draw.ellipse(user_canvas, pg.Color(&quot;darkgreen&quot;), (10, 50, 80, 150))  # first treetop
pg.draw.rect(user_canvas, pg.Color(&quot;brown&quot;), (140, 180, 20, 100))       # second tree
pg.draw.ellipse(user_canvas, pg.Color(&quot;darkgreen&quot;), (110, 50, 80, 150)) # second treetop
pg.draw.rect(user_canvas, pg.Color(&quot;brown&quot;), (240, 180, 20, 100))       # third tree
pg.draw.ellipse(user_canvas, pg.Color(&quot;darkgreen&quot;), (210, 50, 80, 150)) # third treetop
#################

font = pg.font.SysFont(&quot;Arial&quot;, 20)
font.set_bold(True)
mouse_x, mouse_y = 0, 0

should_redraw = True
done = False
while not done:
    if should_redraw:
        draw()
        pg.display.update()
        should_redraw = False

    event = pg.event.wait()
    if event.type == pg.QUIT:
        done = True
    else:
        should_redraw = handle_event(event)

# Completion of the hidden part of the program, that works as an example
pg.quit()
pg.time.set_timer(pg.QUIT,50)
pg.time.wait(70)
pg.time.set_timer(pg.QUIT,0)

# Completion of user program is in the separate section

# -*- acsection: after-main -*-
pygamebg.wait_loop()
" data-enablecopy="true">


</textarea>
</div>
</div>
</div>


  
      <div class="col-md-12">
<ul class="pager">
        <li id="relations-prev" title='Previous chapter - Рисуване на прави линии и многоъгълници' data-toggle="tooltip"><a href="03_PyGame_11b_Drawing_LinePolygon.html">Previous chapter</a></li>
    
        <li id="relations-next" title='Next chapter - Drawing from reference - допълнителни примери' data-toggle="tooltip"><a href="03_PyGame_12b_Drawing_Given_Examples_opt.html">Next chapter</a></li>
</ul>

<!-- <ul class="pager"> -->
    <!-- -->
        <!-- <li id="relations-prev" title='Претходно поглавље - Рисуване на прави линии и многоъгълници' data-toggle="tooltip"><a href="03_PyGame_11b_Drawing_LinePolygon.html">Претходно поглавље</a></li> -->
    <!--  -->
    <!-- -->
        <!-- <li id="relations-next" title='Следеће поглавље - Drawing from reference - допълнителни примери' data-toggle="tooltip"><a href="03_PyGame_12b_Drawing_Given_Examples_opt.html">Следеће поглавље</a></li> -->
    <!-- -->
<!-- </ul> -->

<script type="text/javascript">

  $('#relations-prev').tooltip({'placement':'right', 'selector': '', 'delay': { show: 100, hide: 50}});
  $('#relations-next').tooltip({'placement':'left', 'selector': '', 'delay': { show: 100, hide: 50}});

</script>
</div>
  
</div>
<footer class="footer col-md-12">
    <div class="container text-center">
        <div class="text-center">
            <hr>
            <p class="text-muted">
                <span class="text-center">&copy; 2019 <a href="https://petlja.org">Petlja.org</a> 
                  <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; vertical-align: text-bottom" src="https://i.creativecommons.org/l/by-nc-sa/4.0/80x15.png" /></a>
                  (Created using  <a href="https://pypi.org/project/Sphinx/">Sphinx</a>, <a href="http://runestoneinteractive.org/">RunestoneComponents</a> and <a href="https://github.com/Petlja/PetljaDoc">PetljaDoc</a>)</span>
            </p>
        </div>
    </div>
</footer>



<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-32029811-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>



  </body>
</html>