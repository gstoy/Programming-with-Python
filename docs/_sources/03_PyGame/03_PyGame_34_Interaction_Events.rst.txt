Събития
--------

Когато разчитане на състоянието не е достатъчно
''''''''''''''''''''''''''''''''''''''''''''''''

В началото на раздела за взаимодействието споменахме, че има два основни начина за програма да получи информация за действията на потребителя. Първият начин е да прочетете състоянието на мишката и клавиатурата и вече сме запознати с този начин.

Четенето на състоянията на мишката и клавиатурата е лесно и достатъчно за много приложения. В някои ситуации обаче това не е най-удобният начин за правене на неща. Например, ако искахме да знаем кога потребителят кликва върху мишката:

- честото четене на състоянието на мишката може да доведе до множество последователни четения, показващи, че бутонът на мишката е свален, но не знаем дали е едно и също щракване или е имало повече кликвания.
- рядко четенето на състоянието на мишката може да доведе до това, че потребителят натиска и освобождава бутон след едно четене и преди следващото. В този случай програмата няма да получи информация за това щракване.

.. commented out

    Друга ситуация, при която четенето на състоянието не е най-удобният метод на работа, е когато редът на натискане на клавишите е важен за нас. Да речем, че контролираме символ, използвайки клавишите със стрелки. Четенето може да каже, че стрелките нагоре и надолу са натиснати, но не може да каже коя е била натисната първо. Така че ние не знаем дали героят трябва да върви първо надясно и след това нагоре или нагоре и след това надясно (и вдясно може да има опасно поле).


Let us look at the following example.

.. questionnote::

    **Пример - счупен превключвател:** 
    
    Следващата програма начертава изображение на схема на свързване за всеки кадър, а след това върху него изображения на превключвател и крушка. Идеята е да "включите и изключите светлината", като кликнете върху превключвателя.

Когато решавате задачата, като четете състоянието на мишката, могат да възникнат различни нежелани поведения поради описаните по-горе недостатъци, като например не реагиране на щракване (четене на състоянието твърде рядко) или трептене на светлината (четене на състоянието твърде често ). Дори ако скоростта на щракване е точно правилна, така че можете да избегнете тези нежелани ефекти и нормално да включите или изключите светлината, някой, който кликне по-бързо или по-бавно, може да почувства проблема.

Изпробвайте програмата с щракване с различна скорост.

.. image:: ../../_images/Shema1_Off.png
   :width: 50px
.. image:: ../../_images/Shema1_On.png
   :width: 50px
.. image:: ../../_images/SwitchOff.png
   :width: 50px
.. image:: ../../_images/SwitchOn.png
   :width: 50px
.. image:: ../../_images/BulbOff.png
   :width: 50px
.. image:: ../../_images/BulbOn.png
   :width: 50px

.. activecode:: PyGame__interact_switch_read_state_bad
    :nocodelens:
    :enablecopy:
    :modaloutput:
    :includesrc: src/PyGame/3_Interaction/3d_Mouse_events/Switch_read_state.py

Информация за промените в състоянието
'''''''''''''''''''''''''''''''''''''

Както споменахме във въвеждането на тази глава, можем също да проследяваме действията на потребителя по друг начин, а именно да използваме системни събития. Събитията, които разглеждаме тук, могат да бъдат разбрани като ** промени в състоянието на мишката или клавиатурата ** (макар че има и други събития, като например тези, генерирани от системния часовник). Например, когато клавишът на клавиатурата или бутона на мишката се спусне, операционната система на компютъра получава сигнал от устройството за въвеждане и го регистрира като събитие. Същото се случва в момента на освобождаване на клавишите (бутоните), промяна на позицията на мишката и т.н.

Всички събития се записват и запомнят, така че не може да се случи, че пропуснем действието на потребителя, например когато четем само състоянието.

PyGame библиотеката ни позволява да получим по един обект за всяко събитие с информация за това събитие, да проучим какъв тип събитие е и да отговорим програмно на събитието според нуждите.

Използване на събития в програми
'''''''''''''''''''''''''''''''''

В програми, които използват събития, ще напишем специална функция ``handle_event (event)`` (можете да й дадете различно име). Тази функция получава PyGame обект *събитие* като аргумент, който съдържа цялата необходима информация за събитието. Ние добавяме името на нашата функция за обработка на събития като третия аргумент в повикването на функцията *pygamebg.frame_loop*. Това дава възможност да се извиква нашата *handle_event* функция за всяко събитие, което се случва, докато програмата работи.

Сега нека разгледаме как точно се справяме със събитието.

Във функцията *handle_event* проверяваме дали това събитие е от типа "бутон на мишката се спуска". Ние правим това, като сравняваме типа събитие, съхранено в полето ``event.type``, с константата на PyGamе ``pg.MOUSEBUTTONDOWN``, което има описаното значение.

Ако събитието е от вида, който ни интересува (преместване на бутон на мишката надолу, тоест стартиране на щракване), използвайки командата ``mouse_point = event.pos``, поставяме координатите на точката, където е била мишката по времето, когато събитието се е случило в променливата *mouse_point*, защото искаме да знаем на какво е кликнал потребителят.

Следващите команди проверяват дали потребителят е щракнал върху превключвателя и ако е така, променят стойността на логическата променлива *switch_on*, която показва състоянието на превключвателя.

.. questionnote::

    **Пример - превключвател:** 
    
    Tази програма прави същото като предишната, но използва събитието с мишката надолу, така че няма нежелани ефекти.
   
.. activecode:: PyGame__interact_Switch
    :nocodelens:
    :enablecopy:
    :modaloutput:
    :includesrc: src/PyGame/3_Interaction/3d_Mouse_events/Switch.py

